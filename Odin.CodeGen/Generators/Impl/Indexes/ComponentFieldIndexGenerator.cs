using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Odin.Abstractions.Components;
using Odin.Abstractions.Components.Declaration;
using Odin.CodeGen.Abstractions;
using Odin.CodeGen.Abstractions.Utils;

namespace Odin.Component.CodeGen.Generators.Impl.Indexes;

[Generator]
public class ComponentFieldIndexGenerator : AComponentIncrementalGenerator
{
    private static readonly string IndexByFullName = typeof(IndexByAttribute).FullName!;

    protected override void GenerateCode(
        GeneratorExecutionContext context,
        IEnumerable<INamedTypeSymbol> components
    )
    {
        var indexedComponents = components.Where(c =>
        {
            var members = c.GetMembers();
            var attributes = members.SelectMany(w => w.GetAttributes());

            return attributes.Any(a => a.AttributeClass!.ToDisplayString() == IndexByFullName);
        });

        foreach (var indexedComponent in indexedComponents)
        {
            GenerateIndexDefinitions(context, indexedComponent);
        }
    }

    private string GetComponentName(INamedTypeSymbol symbol)
    {
        var name = symbol.Name;

        var parent = symbol.ContainingSymbol;
        while (parent != null && parent is not INamespaceSymbol)
        {
            name = $"{parent.Name}_{name}";
            parent = parent.ContainingSymbol;
        }

        return name;
    }

    private void GenerateIndexDefinitions(
        GeneratorExecutionContext context,
        INamedTypeSymbol component
    )
    {
        var namespaceName = component.ContainingNamespace.ToDisplayString();
        var componentName = GetComponentName(component);
        var indexName = $"{componentName}Index";

        var path = namespaceName.Replace('.', '/');
        var fullPath = $"{path}/{indexName}";

        var indexes = ComponentFieldProcessor.GetFieldDeclarations(component.GetMembers())
                                             .Where(c => c.IsIndex)
                                             .Select(c =>
                                              {
                                                  var name = c.Name;
                                                  var type = c.Type.GetFieldType();

                                                  if (c.CollectionType != ECollectionType.None)
                                                  {
                                                      return $@"
    public IEntitiesCollection {name}(params {type}[] values)
    {{
        throw new System.NotImplementedException();
    }}

    public IEntitiesCollection {name}Contains(params {type}[] values)
    {{
        throw new System.NotImplementedException();
    }}

    public IEntitiesCollection {name}ContainsAny(params {type}[] values)
    {{
        throw new System.NotImplementedException();
    }}
";
                                                  }
                                                  else
                                                  {
                                                      return $@"
    public IEntitiesCollection {name}({type} value)
    {{
        throw new System.NotImplementedException();
    }}
";
                                                  }
                                              });

        var indexCode = $@"
// <auto-generated/>

using System;
using Odin.Abstractions.Entities.Indexes;
using Odin.Abstractions.Entities;

namespace {namespaceName};

public abstract class A{indexName} : AComponentFieldIndex
{{
}}

public sealed class {indexName} : A{indexName}
{{
    public IEntitiesCollection GetEntities()
    {{
        throw new System.NotImplementedException();
    }}

    {string.Join("\n\t\t\t", indexes)}
}}
";

        context.AddSource($"{fullPath}.g.cs", SourceText.From(indexCode, Encoding.UTF8));

        var extensionName = $"{componentName}IndexExtensions";
        var extensionFullPath = $"{path}/{extensionName}";

        var extensionCode = $@"
// <auto-generated/>

using Odin.Abstractions.Entities.Indexes;
using Odin.Abstractions.Contexts;

namespace {namespaceName};

public static class {extensionName}
{{
    public static {indexName} Index<T>(this AEntityContext context) where T : A{indexName}
    {{
        if (typeof(T) != typeof({indexName}))
        {{
            throw new System.ArgumentException(nameof(T));
        }}

        throw new System.NotImplementedException();
    }}
}}
";

        context.AddSource($"{extensionFullPath}.g.cs", SourceText.From(extensionCode, Encoding.UTF8));
    }
}