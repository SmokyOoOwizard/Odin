using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Odin.Abstractions.Collectors.Matcher;
using Odin.CodeGen.Abstractions;
using Odin.CodeGen.Abstractions.Utils;

namespace Odin.Component.CodeGen.Generators.Impl.Matchers;

[Generator]
public class MatcherFilterGenerator : AComponentMatcherIncrementalGenerator
{
    protected override void GenerateCode(GeneratorExecutionContext context, IEnumerable<INamedTypeSymbol> matchers)
    {
        var namespaceName = context.Compilation.AssemblyName;

        var methodBody = matchers
           .Select(s =>
            {
                var fullName = s.OriginalDefinition.ToDisplayString();

                var members = s.GetMembers()
                               .First(c => c.Name == nameof(AComponentMatcher.Configure) && c is IMethodSymbol);


                var w= members.DeclaringSyntaxReferences.First();

                var node = w.GetSyntax() as MethodDeclarationSyntax;

                Parse(node!);
                
                return $"""
                             
                        """;
            }).ToArray();

        var code = $@"
// <auto-generated/>

using Odin.Abstractions.Components.Declaration;
using Odin.Abstractions.Components.Declaration.Builder.States;
using Odin.Abstractions.Components.Utils;

namespace {namespaceName};
public class MatcherFilterQ
{{

}}
";

        context.AddSource("ComponentDeclarations.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    private void Parse(MethodDeclarationSyntax node)
    {
        var n = node.Body.ChildNodes().First();
        var rawNode = n.ToString();

        if (!rawNode.StartsWith("Filter()."))
            throw new Exception(); // todo

        rawNode = rawNode.RemoveComments();
        rawNode = rawNode.Replace("Filter()", "");

       var parsedFilter= ParseFunction(rawNode);
        
        return;
    }

    private FilterComponent[] ParseArguments(string text)
    {
        text = text.Trim();
        if (string.IsNullOrWhiteSpace(text))
            return Array.Empty<FilterComponent>();

        var arguments = new List<FilterComponent>();

        var tailStart = 0;
        while (tailStart < text.Length)
        {
            var substring = text.Substring(tailStart);
            var end = 0;
            while (true)
            {
                var stringWithOffset = substring.Substring(end);
                var group = StringParser.ParseRecursiveGroups(stringWithOffset);
                if (group.StartIndex == -1)
                {
                    break;
                }

                end += group.EndIndex;

                var tail = stringWithOffset.Substring(group.EndIndex);
                var commaOffset = tail.IndexOf(',');
                if (commaOffset != -1)
                {
                    var stringBeforeComma = tail.Substring(0, commaOffset);
                    if (string.IsNullOrWhiteSpace(stringBeforeComma))
                        break;
                }
            }

            var funcOffset = substring.IndexOf('.');
            var funcText = substring.Substring(funcOffset, end - funcOffset);

            var parsedFunction = ParseFunction(funcText);
            arguments.Add(parsedFunction);

            var commaIndex = substring.IndexOf(',') + 1;
            if (commaIndex == 0)
            {
                break;
            }

            tailStart += commaIndex;
        }


        return arguments.ToArray();
    }

    private FilterComponent ParseFunction(string text)
    {
        var group = StringParser.ParseRecursiveGroups(text);
        if (group.StartIndex == -1)
            return new FilterComponent() { Type = EFilterType.Unknown };

        var dotIndex = text.IndexOf('.');
        var methodName = text.Substring(dotIndex + 1, group.StartIndex - 1);
        var genericArg = string.Empty;

        var genericStart = methodName.IndexOf('<');
        var genericEnd = methodName.IndexOf('>');
        if (genericStart != -1 && genericEnd != -1)
        {
            genericArg = methodName.Substring(genericStart + 1, genericEnd - genericStart - 1);
            methodName = methodName.Substring(0, genericStart);
        }

        var methodType = GetFilterType(methodName);

        var chain = new List<FilterComponent>();

        var tailStart = group.EndIndex;
        while (tailStart < text.Length)
        {
            var tailRaw = text.Substring(tailStart, text.Length - tailStart);
            var body = StringParser.ParseRecursiveGroups(tailRaw);
            if (body.StartIndex == -1)
                break;

            var tailPart = tailRaw.Substring(0, body.EndIndex);
            tailStart += tailPart.Length;

            chain.Add(ParseFunction(tailPart));
        }

        var children = ParseArguments(group.InnerText);

        var parsed = new FilterComponent
        {
            GenericArg = genericArg,
            Type = methodType,
            Children = children
        };

        if (chain.Count > 0)
        {
            var parentChildren = new List<FilterComponent>
            {
                parsed
            };
            parentChildren.AddRange(chain);

            var parent = new FilterComponent
            {
                Type = EFilterType.All,
                Children = parentChildren.ToArray()
            };

            return parent;
        }


        return parsed;
    }

    private EFilterType GetFilterType(string str)
    {
        var type = str switch
        {
            "Any" => EFilterType.Any,
            "All" => EFilterType.All,
            "Not" => EFilterType.Not,
            "Has" => EFilterType.Has,
            "NotHas" => EFilterType.NotHas,
            "Added" => EFilterType.Added,
            "Removed" => EFilterType.Removed,
            "AnyChanges" => EFilterType.AnyChanges,
            _ => EFilterType.Unknown
        };

        return type;
    }

    public struct FilterComponent
    {
        public EFilterType Type;
        public string GenericArg;
        public FilterComponent[] Children;
    }

    public enum EFilterType
    {
        Unknown,
        All,
        Any,
        Not,
        Has,
        NotHas,
        Added,
        Removed,
        AnyChanges
    }
}